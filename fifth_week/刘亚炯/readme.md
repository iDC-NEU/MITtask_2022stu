## lab4A:分布式KV缓存控制器Shardctrler的实现

Lab4就是要实现分库分表，将不同的数据划分到不同的集群(group)上，并保证将相应数据请求引流到对应的集群。group就是一组Raft服务器, 由于raft协议的保证, 可以简化认为一个group即是一台服务器.

这里将互不相交并且合力组成完整数据库的每一个数据库子集称为shard，里面包括了一些Key-Value键值对, 本次lab确定了一共有10个shard。

在同一阶段中，shard与group的对应关系称为配置，configs。随着时间的推移，新集群的加入或者现有集群的离去，shard需要在不同集群之中进行迁移以保证负载均衡。当配置变化时需要处理好shard的移动。

一个集群只有Leader才能服务，系统的性能与集群的数量成正比。lab3是一个集群，lab4A所要实现的是多个集群之间的配合。

**主要实现了4个RPC操作**

- Join：加入一个新的组 ，创建一个最新的配置。参数是一组从唯一的非零副本组标识符 (GID) 到服务器名称列表的映射。join之后需要进行负载均衡

- ```Go
  Servers map[int][]string // new GID -> servers mappings
  ```

- Leave: 撤离给定的一个组。参数是以前加入的组的 GID 列表。注意：需要将被撤离组的分片均匀的，尽可能较少次移动的重新分配给剩下的组即负载均衡

- ```Go
  GIDs []int
  ```

- Move: 为指定的分片，分配指定的组。参数是一个分片号和一个组号。

- Query: 查询特定的配置版本，如果给定的版本号不存在切片下标中，则直接返回最新配置版本。

**重复客户端请求检测**

和lab3类似，这里在每个RPC请求的参数内加入clientId（客户端号）和seqId（随请求自增），根据clientId和seqId来判断该操作是否重复。

**负载均衡**

在组的加入和离开时需要进行负载均衡，主要步骤如下：

1. 首先对根据负载的情况进行排序，要记住的是如果有负载相同的情况下，需要对gid也进行排序，生成唯一序列。通过排序就进行更少的交换，当然要确保这个过程中不会有Move等操作影响负载。理想负载的情况并不可能均分，如10个分片分给4个组并不能是{2.5，2.5，2.5，2.5}。而应该是{3，3，2，2}。对于这种情况就可以根据排序后的序列就可以通过预期的个数，确定哪几个组需要多负载一个分片。
2. 通过排序后的gid循环找到当前负载较多和较为空闲的组，对它们进行互补即可。

假设现在有10个分片，分配给4个组,且现在的负载情况为 **{3，3，3，1}**，则当前第三个组分配了3个shard是**负载比较多的组**，而第四个组分配了1个shard是**比较空闲的组**，进行互补操作后负载结果就是**{3，3，2，2}**。

当前程序已经通过了lab4A的所有测试。