#### lab2A:实现leader的产生和保持

1、给每一个server设一个计时器，rand一个overtime。当其中一个到达overtime触发选举。

2、选举时，candidate向其他server发送投票请求。server根据log_index和term决定投票与否。获得半数以上的candidate成为leader。

3、leader每隔一段时间(hearbeatTimeout)向每个follower发送心跳包，重置其计时器，保证领导地位。



#### lab2B：实现日志同步

1、日志的同步通过2A中心跳包实现，将2A中的心跳包由原来的无信息改为包含log[]。

2、要预防网络分区的出现，否则会使小部分分区的server不断选举，term暴增，这样真正的leader中的log会实效。(第一个犯的错误)

3、PrelogIndex用来为维护并行添加日志的顺序。(查资料之前不知道它是干嘛的，导致日至顺序出错)

4、最简单的也是最难受的就是要判断是否是leader操作，不然不要乱改日志！

尽管是这样，程序还是有一定的bug，时间原因还没有找到问题，但是bug出现的很偶然，有时有很经常。摸不清头脑了，可能总是觉得自己考虑的够多了。还是要重新看一边论文，是不是落下了什么细节。



#### lab2C：实现server的持久化处理

这部分主要对currentterm、[]log、voteFor进行持久化存储。持久化函数lab中已经给出。

测试没有过，查了下资料，看了下论文，发现自己忘记了将日志回退。(我是。。。)正在想办法修改



#### 总体来看，2A完成的很完美。2B觉得很难，经常漏掉很多需要容错的部分；还总是使用单机编程的思想，上锁总是最后程序出问题才想起来。所以，2B的测试出现问题。还是需要继续学习！



**8.14补充Lab2D：快照**

补充的看了一下论文的日志压缩部分，随着raft的工作，（由于raft只append日志不覆盖）日志数量将持续增长，使用“快照”功能可以解决这个问题。

在日志到达一定的数量之后，将已经提交的日志作为快照保存到持续化存储中，然后将已经提交的日志删除，以减少raft的Log数组大小。实验2D用来实现快照，并作为Lab3B的基础。快照这部分描述，论文里面给了详细的数据结构以及工作过程。