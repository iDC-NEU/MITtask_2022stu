#### lab2A:实现leader的产生和保持

1、给每一个server设一个计时器，rand一个overtime。当其中一个到达overtime触发选举。

2、选举时，candidate向其他server发送投票请求。server根据log_index和term决定投票与否。获得半数以上的candidate成为leader。

3、leader每隔一段时间(hearbeatTimeout)向每个follower发送心跳包，重置其计时器，保证领导地位。



#### lab2B：实现日志同步

1、日志的同步通过2A中心跳包实现，将2A中的心跳包由原来的无信息改为包含log[]。

2、要预防网络分区的出现，否则会使小部分分区的server不断选举，term暴增，这样真正的leader中的log会实效。(第一个犯的错误)

3、PrelogIndex用来为维护并行添加日志的顺序。(查资料之前不知道它是干嘛的，导致日至顺序出错)

4、最简单的也是最难受的就是要判断是否是leader操作，不然不要乱改日志！

尽管是这样，程序还是有一定的bug，时间原因还没有找到问题，但是bug出现的很偶然，有时有很经常。摸不清头脑了，可能总是觉得自己考虑的够多了。还是要重新看一边论文，是不是落下了什么细节。



#### lab2C：实现server的持久化处理

这部分主要对currentterm、[]log、voteFor进行持久化存储。持久化函数lab中已经给出。

测试没有过，查了下资料，看了下论文，发现自己忘记了将日志回退。(我是。。。)正在想办法修改



#### 总体来看，2A完成的很完美。2B觉得很难，经常漏掉很多需要容错的部分；还总是使用单机编程的思想，上锁总是最后程序出问题才想起来。所以，2B的测试出现问题。还是需要继续学习！